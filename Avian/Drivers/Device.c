/**
 * @file		Device.h
 * @ingroup		DriverAPI
 * @author		Freie Universitaet Berlin, Tomasz Naumowicz
 */

#include <signal.h>

#include "Device.h"

#include "../System/Logging.h"

#include "../System/BitOperations.h"
#include "../System/Types.h"
#include "../System/System.API.h"
#include "../System/Timers.API.h"
#include "../System/Commands.API.h"
#include "../System/Watchdog.API.h"
#include "../System/Radio/Network.h"

#include "Venus.API.h"
#include "ADC_Devices.h"
#include "SCP1000-D01.API.h"
#include "LogEngine.h"
#include "LogEngine.Sync.h"
#include "M25P80.API.h"


void Avian_InitPorts() {
	
	/*
	 * After a POR, the initial MSP430 conditions are:
	 *  - The RST/NMI pin is configured in the reset mode.
	 *  - I/O pins are switched to input mode as described in the Digital I/O chapter.
	 *  - Other peripheral modules and registers are initialized as described in their
	 *    respective chapters in this manual.
	 *  - Status register (SR) is reset.
	 *  - The watchdog timer powers up active in watchdog mode.
	 *  - Program counter (PC) is loaded with address contained at reset vector
	 *    location (0FFFEh). CPU execution begins at that address.
	 * 
	 * POR == POWER-ON RESET
	 * PUC == POWER-UP CLEAR
	 * 
	 * AWARE: different power on conditions after POR and PUC
	 * 
	 * AWARE: watchdog timer generates PUC not POR
	 * 
	 * A POR is a device reset. A POR is only generated by the following three
	 * events:
	 *  - Powering up the device
	 *  - A low signal on the RST/NMI pin when configured in the reset mode
	 *  - An SVS low condition when PORON = 1.
	 * 
	 * A PUC is always generated when a POR is generated, but a POR is not
	 * generated by a PUC. The following events trigger a PUC:
	 *  - A POR signal
	 *  - Watchdog timer expiration when in watchdog mode only
	 *  - Watchdog timer security key violation
	 *  - A Flash memory security key violation
	 * 
	 * 
	 * Unused I/O pins should be configured as I/O function, output direction, and left
	 * unconnected on the PC board, to reduce power consumption.
	 * 
	 */
	
	/**
	 * Avian V4
	 */

	//====PORT1====================================================================
	P1SEL = 0x00;		// Port1 function:			00000000 = 0x00 (0 == GPIO, 	1 == second function)
	P1OUT = 0xD8;		// Port1 output registers: 	11011000 = 0xD8 (0 == low, 		1 == high)
	P1DIR = 0xFD;		// Port1 direction: 		11111101 = 0xFD (1 == output, 	0 == input)
	
						// P1.0 [OUTPUT]			nc
						// P1.1 [INPUT]				gps.P1PPS
						// P1.2 [OUTPUT]			nc
						// P1.3 [OUTPUT]			LED1 (high == led off)
						// P1.4 [OUTPUT]			Pressure_PwrDn (high == pressure sensor off, low == pressure sensor on: needs to be on for operation and SPI communication)
						// P1.5 [OUTPUT]			Test Point 2
						// P1.6 [OUTPUT]			LED2 (high == led off)
						// P1.7 [OUTPUT]			Pressure_CS (high)
	//====PORT2====================================================================
	P2SEL = 0x00;	 	// Port2 function			00000000 = 0x00 (0 == GPIO, 	1 == second function)
	P2OUT = 0x01;		// Port2 output registers:	00000001 = 0x01 (0 == low, 		1 == high)
	P2DIR = 0x3B;		// Port2 direction: 		00111011 = 0x1B (1 == output, 	0 == input)
	
						// P2.0 [OUTPUT]			CC1101_CSN (high)
						// P2.1 [OUTPUT]			Test Point 1
						// P2.2 [INPUT]				Pressure_DRDY 
						// P2.3 [OUTPUT]			nc
						// P2.4 [OUTPUT]			nc
						// P2.5 [OUTPUT]			not properly connected	Rosc (special function), although http://focus.ti.com/lit/ds/symlink/msp430f1611.pdf says "DCOR: Control Bit From Basic Clock Module If it Is Set, P2.5 Is Disconnected From P2.5 Pad" on page 53
						// P2.6 [INPUT]				CC1101_GDO2
						// P2.7 [INPUT]				CC1101_GDO0
	//====PORT3====================================================================
	P3SEL = 0xFE;		// Port3 function:			11111110 = 0xFE (0 == GPIO, 	1 == second function)
	P3OUT = 0x10;		// Port3 output registers:	00010000 = 0x10 (0 == low, 		1 == high)
	P3DIR = 0xFB;		// Port3 direction: 		11111011 = 0xFB (1 == output, 	0 == input, x == don't care)
	
						// P3.0 [OUTPUT]			nc
						// P3.1 [2nd fct]			SIMO0 (spi) /output/
						// P3.2 [2nd fct]			SOMI0 (spi) /input/
						// P3.3 [2nd fct]			UCLK0 (spi) /output/
						// P3.4 [2nd fct]			UTX0 (debug, fallback to output.high - to reduce noise when reconfiguring)
						// P3.5 [2nd fct]			URX0 (debug, fallback to output.low)
						// P3.6 [2nd fct]			UTX1 (gps, fallback to output.low - to reduce power stealing when disabling the GPS)
						// P3.7 [2nd fct]			URX1 (gps, fallback to output.low)
	//====PORT4====================================================================
	P4SEL = 0x00;		// Port4 function			00000000 = 0x00 (0 == GPIO, 	1 == second function)
	P4OUT = 0x04;		// Port4 output registers:	00000100 = 0x04 (0 == low, 		1 == high)
	P4DIR = 0xFF;		// Port4 direction:			11111111 = 0xFF (1 == output, 	0 == input)

						// P4.0 [OUTPUT]			nc
						// P4.1 [OUTPUT]			nc
						// P4.2 [OUTPUT]			flash.nWP (high - no write protection)
						// P4.3 [OUTPUT]			nc
						// P4.4 [OUTPUT]			nc
						// P4.5 [OUTPUT]			nc
						// P4.6 [OUTPUT]			nc
						// P4.7 [OUTPUT]			nc
	//===PORT5====================================================================
	P5SEL = 0x00;		// Port5 function			00000000 = 0x00 (0 == GPIO, 	1 == second function)
	P5OUT = 0x11;		// Port5 output registers:	00010001 = 0x11 (0 == low, 		1 == high)
	P5DIR = 0xFF;		// Port5 direction:			11111111 = 0xFF (1 == output, 	0 == input)

						// P5.0 [OUTPUT]			flash.nHold (high - enable spi communication)
						// P5.1 [OUTPUT]			nc
						// P5.2 [OUTPUT]			nc
						// P5.3 [OUTPUT]			nc
						// P5.4 [OUTPUT]			flash.nCS (high)
						// P5.5 [OUTPUT]			GPS_PWR (low)
						// P5.6 [OUTPUT]			GPS_GPIO24 (low)			
						// P5.7 [OUTPUT]			nc
	//====PORT6====================================================================
	P6SEL = 0x82;		// Port6 function			10000010 = 0x00 (0 == GPIO, 	1 == second function)
	P6OUT = 0x00;		// Port6 output registers:	00000000 = 0x00 (0 == low, 		1 == high)
	P6DIR = 0x7D;		// Port6 direction:			01111101 = 0x7D (1 == output, 	0 == input)

						// P6.0 [OUTPUT]			nc
						// P6.1 [INPUT]				BAT_VSENSE sel=1			
						// P6.2 [OUTPUT]			Light.Collector
						// P6.3 [OUTPUT]			nc
						// P6.4 [OUTPUT]			pressure.TRIG
						// P6.5 [OUTPUT]			nc
						// P6.6 [OUTPUT]			nc
						// P6.7 [INPUT]				Light.Emmiter sel=1

	/**
	 * NOTE: Analog signals applied to digital gates can cause current flow from the positive to the negative terminal.
	 * The throughput current flows if the analog signal is in the range of transitions 0->1 or 1<-0.
	 * The value of the throughput current depends on the driving capability of the gate. For MSP430, it is approximately 100 uA.
	 * 
	 * Use P6SEL.x=1 to prevent throughput current. P6SEL.x should be set, even if the signal at the pin is not being used by the ADC12.
	 */
}

void Avian_CriticalLPM4(uint8_t code) {
	/**
	 * this is only a proof of concept
	 * actually, this should be somewhere in the app
	 * and prior to switching off the MC, all known devices should be disabled, etc...
	 */

	WDTCTL = WDTPW | WDTHOLD;	// stop the watchdog --> this function will terminate
	
	LOGERR("Critcal Stop: %u", code);
	
	Network_PowerOff();
	Venus_PowerOff();
	
	_DINT();

	/*
	 * debug test code useful when testing power down states
	 * 
			if ((GPS_GPIO24_OUT & GPS_GPIO24_PIN)) {
				LED1_ON; // problem!
			}
		
			if ((FLASH_CS_OUT & FLASH_CS_PIN) == 0) {
				LED1_ON; // problem!
			}
		
			if ((CC_CSn_OUT & CC_CSn_PIN) == 0) {
				LED1_ON; // problem!
			}
		
			if ((SCP_CS_OUT & SCP_nCS_PIN) == 0) {
				LED1_ON; // problem!
			}
			
			while(1) {
				LPM4;
			}
	*/
	
	
	uint8_t i, k;

	for (k = 3; k > 0; k--) {
		
		// toggle led1 and led2 to gain attention of the user
		LED1_OFF;
		LED2_ON;
		
		for (i = 40; i > 0; i--) {
			LED1_TOGGLE;
			LED2_TOGGLE;
			Timers_Block(1024);
		}
		
		LED1_OFF;
		LED2_OFF;
		
		// toggle led1 and led2 simultanously to communicate the error message to the user
		for (i = code; i > 0; i--) {
			Timers_Block(4096);
			LED1_ON; LED2_ON;
			Timers_Block(2048);
			LED1_OFF; LED2_OFF;
		}

		Timers_Block(TICKS_SECOND);
	
	} // for (3 times loop)

	// put the device into sleep.
	while(1) {
		LPM4;
	}
}

void LogResetReason() {
	wd_resetinfo_t resetInfo;
	Watchdog_ReadResetReason(&resetInfo);
	
	logentry_t log;
	LogEngine_PrepareLogEntry(&log);
	log.TypeId = Debug;
	log.Payload.Debug.DebugCode = 11;
	log.Payload.Debug.Value1_8bit = resetInfo.Password;
	log.Payload.Debug.Value2_8bit = resetInfo.ResetReason;
	log.Payload.Debug.Value4_16bit = resetInfo.FunctionPointer;
	log.Payload.Debug.Value5_16bit = resetInfo.StackPointer;

	LogEngine_Save(&log);
}

init_drivers_result_t Avian_InitDrivers() {
	// init sensors
	LOG("Init sensors...");

	// initializing the log engine (and indirectly the flash memory)
	if (false == LogEngine_Init())
		return LogEngine_Failure;
	
	LogResetReason();
	
	// initialize the sync only if everything went fine until now (if LogEngine_Init went fine)
	LogEngine_Sync_Init();

	// initializing the pressure + temperature sensor
	if (false == SCP_Enable(true))
		return SCP_Failure;
	
	// disalbe the sensor (saving energy if not used);
	SCP_Disable();
	
	// initializing the ADC devices
	ADC_Devices_Init();
	
	// battery voltage check
	{ 
		char asString[BATTERY_READ_STRING_LENGTH];

		SET(GPS_PWR_OUT, GPS_PWR_PIN);
		Timers_Block(4096);
		
		ADC_Devices_Battery_Read(NULL, asString);

		CLEAR(GPS_PWR_OUT, GPS_PWR_PIN);
		Timers_Block(4096);
	
		LOG("Battery: %s", asString);
	}

	// initializing the VenusGPS chip (and indirectly the USART1)
	if (false == Venus_Init())
		return VenusGPS_Failure;

	LOG("Init sensors: OK");

	return Init_Success;
	
	// execute Power On Self Test (executes only during the first run of the firmware)
	// during the firmware development, no useful self tests were identified
	// the only test that was executed here was the test of the flash memory
	// this test will be extracted to an extra command so that it can be run manually.
}

/**
 * @ingroup Commands
 * @brief	@b selftest Performs self test of the device.
 */
COMMAND(selftest, "Device Self Test", cmd_args) {
	bool flash_ok = Flash_SelfTest();
	if (flash_ok)
		LogEngine_Init();
}

#ifndef DOXYGEN_PUBLIC_DOC
/**
 * Copyright (c) 2011 Freie Universitaet Berlin, Tomasz Naumowicz. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 * 
 * - Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * 
 * - Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * 
 * - Neither the name of the Freie Universitaet Berlin nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Freie Universitaet Berlin BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#endif // DOXYGEN
